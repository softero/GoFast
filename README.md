# GoFast Quick Start

The GoFast application is designed to be a convenient system to handle simple
stream based analysis and event-based scripting. There are two componeents that
we will deal with: the stream engine and the event engine.

Basic usage of GoFast is to create a script file ("myscript.fast") and then
invoke the application on it with:

    ./gofast run myscript.fast

The application will look for scripts to add to the Lua environment under `./scripts`
and operators will be searched for in `./operators`. More information below.

# Stream engine

The stream engine allows you to conduct simple stream processing of tuples. If
you are not familiar with stream processing, it works by operator on small
bits of data. For example, a stream processor might specify a stream to operator
on each frame of data from a security camera received in sequence. It might also
be the individual lines of a file.

A stream is defined as a series of operators, each performing a single function or
transformation on the data stream. One operator might aggregate the data by
identifying the largest and smallest values that occur over a one minute period.
Another might filter values. Another might split the values into multiple values
(such as receiving an object that contains a list of strings and emitting an object
with only one string for each string in the list). Below is an example stream file:

    files = FromFile(fileName="example.txt");

    files -> inline{`
        print("Received: " .. tuple[1])
    `};

This defines an operator that is an instantiation of `FromFile` to read the file
"example.txt". Any output from this operator is sent to an inline operator that
prints out the first field in the tuple. Here is another example:

    myFilter = Filter(filter=`tuple[1] == "greeting"`) -> (inline{`
        print("match: " .. tuple[1])
    `}, inline{`
        print("no match: " .. tuple[1])
    `});

This defines an invocation of a filter that will determine whether a function
matches the test predicate. The filter is connected to two inline operators. The
first operator here will accept tuples that are sent on the first output port of
the filter (`Submit(0, <tuple>)`). The second will accept tuples sent to the
second output port of the filter.

Unfortunately, there are currently no built-in operators, though that is expected
to change in the future.

In GoFast, these operators are written in Lua, with more languages to be supported
in the future. There are two primary types of operators. A Lua standalone operator
and a Lua inline operator.

## Lua standalone operator

The Lua standalone operator can be generated by calling the executable with
the arguments

    ./gofast gen -lua operators/<operator 1 name> -lua operators/<operator 2 name>

The script will append `.lua` to the end of the file for you. It will also split
a namespace into subdirectories. So, if you generate a Lua operator with:

    ./gofast gen -lua operators/com.example.MyOperator

Then, GoFast will generate a file at `operators/com/example/MyOperator.lua`. The
pre-populated template should guide you. There are 4 functions that are availabe to the
operators. These are:

* `Init`, which is called when the operator is first created.
* `Start`, which is called when the stream engine is starting, and tuples can be submitted.
* `Process`, which is called each time a tuple is received by the operator.
* `Stop`, which is called when the operator should stop sending tuples and should shutdown cleanly.

The provided argument `context` provides a function to the operator to submit tuple to the
downstream operators connected to the operator via `context.Submit(<port id>, <tuple>)`.

There are also two modules that are availabe in the Lua virtual machine. These are
`gofast` and `book`. `gofast` provides functions to support asynchronous and periodic
execution of functions and submitting of events. `book` exposes a global registry that
can be used to share state across all operators and event chains in the GoFast engine.
Specifics are documented in the *Lua modules* section.

# Event engine

Many systems have "event processing" included. However, GoFast is an attempt to make
a true complex event processing engine. Most event engines only allow defining triggers
on a single event or some combination of events. But there is no concept of events
happening within a certain time of each other.

The best way to demonstrate is to provide an example.

    on EventA
    -> EventB within 30 seconds then {`doThing()`} else {`doOtherThing()`}
    -> EventC and (EventD or EventE within 5 seconds) then {`
        extraThings()
    `};

This specifies an "event chain." The chain starts when `EventA` is seen. Then the chain
advances to the next phase. This phase specifies that `EventB` should be seen within 30
seconds of entering the phase. There are two actions attached to this phase. The first
is `then`, which is a code block that should be executed when the phase successfully
completes. The `else` action will be executed if the phase is no longer satisfiable.

If `EventB` is seen within 30 seconds, then the success action (`then`) is executed.
If the event has not been seen after 30 seconds, then the fail action (`else`) is run.

The next phase gives a more complex condition for success. `EventC` must be seen, and
there is no time requirement for it. Additionally, either `EventD` must be seen after
any amount of time or `EventE` must be seen within 5 seconds of advancing to this phase.
Importantly, this phase has no time requirement for C or D, and is therefore always
satisfiable. An `else` block attached to this last phase will never execute because
the phase will never be unsatisfiable.

Currently, there is a known limitation that the fail conditions do not run at the correct
time. There is no continuous checking of satisfiability. It will check whenever an event
that is valid for the chain is fired. For example, if we are at the second phase (looking
for `EventB`) and 30 seconds passes, the fail event will not fire until an `Event{A-E}`
occurs and the system checks the satisfiability state of the chain. Acceptable and
performant solutions to this limitation are still being investigated.

Additionally, if a phase has no time limitations, it can lead to effective memory leaks,
as the chain instance will never be seen as unsatisfiable. Therefore, it is recommended
that all phases should be defined in such a way that they can become unsatisfiable at
some point in the future.

Time restrictions can use any combinations of `weeks`, `days`, `hours`, `minutes`, `seconds`,
and `milliseconds`. All of them are pluralized, even if the number is singular. The
numbers must be whole numbers. Additionally, they must be in descending order of scale,
where

    weeks > days > hours > minutes > seconds > milliseconds

So a valid time constraint could be as specific as

    on MyEvent within 1 weeks 3 days 40 hours 61 minutes 1 seconds 500 milliseconds

Event actions for both success and fail are wrapped as functions which take a list of
`events`, which contains the instances of each event that matched with that event.
This is 1-indexed. All values of that event are available, so if the first event fires
with a values tuple defined as `{timestamp=123, source="Refrigerator"}`, the event
information is available as `events[1].source`.

Events in the chain can also have filters. Filters are also wrapped in functions that
accept the list of events and a variable `i` that defines the current state of the
chain. Example:

    on MyEvent -> MyEvent(`events[i].source = events[i-1].source`) within 10 seconds

This specifies that a `MyEvent` must fire with the same source as the previous `MyEvent`
to be accepted.

The order of the events is the order they appear on the chain. `A -> (B or C) and D -> E`
becomes `A, B, C, D, E`.

# Lua modules

The following Lua modules are available in scripts and operators. These can be included
with the standard `local <module> = require("<module>")`.

## gofast

* `gofast.Every(<duration>, <function>)` -- specifies a function to run periodically.
  The duration should be a string such as "1s" or "1h36m," corresponding to hours,
  minutes, and seconds. Any string that is parseable from Golang's `time.ParseDuration`
  is valid.
* `gofast.Async(<function>)` -- runs a Lua function asynchronously. This can be
  useful for a source operator that will generate tuples by reading files, etc.
* `gofast.After(<duration>, <function>)` -- specifies a Lua function to run after a
  certain duration. The format of the duration is the same as in the `Every` function.
* `gofast.Event(<name>, <values>)` -- submit an event to the event engine. `name` should
  be a string. `values` should be an associative table containing only string keys. The
  values can be strings, numbers, lists of strings, lists of numbers, or more associative
  tables.
* `gofast.Log(<message>)` -- sends a message to the logger to be printed out. When it
  is printed, a timestamp is prepended to it. It is really just a wrapper to Golang's
  `log.Println` function.

## book

The book module is essentially a wrapper for a globally accessible associative table.
It includes type checking to allow a guarantee that the value is of a certain type.
For type-checked getters, the function will return `nil` if the key is not defined or
is not the specified type.

* `book.Get(<key>)` -- retrieve a value without type checking. Returns `nil` if the key
  is not set.
* `book.GetType(<key>)` -- returns a string specifying the type of the key.
    * "nil"
    * "string"
    * "int"
    * "float"
    * "stringlist"
    * "intlist"
    * "floatlist"
    * "tuple"
* `book.GetString(<key>)`/`SetString(<key>, <value>)`
* `book.GetInt(<key>)`/`SetInt(<key>, <value>)`
* `book.GetFloat(<key>)`/`SetFloat(<key>, <value>)`
* `book.GetStringList(<key>)`/`SetStringList(<key>, <value>)`
* `book.GetIntList(<key>)`/`SetIntList(<key>, <value>)`
* `book.GetFloatList(<key>)`/`SetFloatList(<key>, <value>)`
* `book.GetTuple(<key>)`/`SetTuple(<key>, <value>)`

## Custom scripts

Additionally, any Lua files in the scripts directory will be loaded into the Lua
runtime and are available without the use of `require`. These are namespaced according
to subdirectory. So, the functions defined in `scripts/MyScript.lua` will be
loaded in as globals. Functions defined in `scripts/subspace/MyScript.lua` will be
loaded into the `subspace` global table in Lua, so they would be available as
`subspace.MyFunction1()`. Multiple files can be loaded from the same namespace, so
functions can be logically separated for the convenience of the script author. The
downside to this is that if two files in the same directory define a identically
named functions, one will overwrite the other. The behavior of this is undefined.

To create a script, use the generate action of GoFast. This is done the same way
as generating a standalone operator, but uses the `-script` flag instead.

    ./gofast gen -script scripts/subspace.MyFunctions

will create a template file in `scripts/subspace/MyFunctions.lua`.

# Extra information

As mentioned, these operators are written in Lua. To add to the confusion, Lua
uses 1-indexed lists, so tuples and events begin at `[1]` and end at `[n]`. The
submit function on the operator context, however, is designed to be consistent
between Lua and future languages that are supported, so it is 0-indexed. Therefore,
the first field of a tuple is `tuple[1]`, but to submit a tuple to the first
output port of an operator, it is invoked with `context.Submit(0, <tuple>)`.

All script files can intermix event chains and operators/streams freely. A single
file can define any number of operators and streams and any number of 

## Disclaimer!

This is alpha level software. Bugs, crashes, and memory leaks are very possible
and to be expected. By using this software, you are helping to improve and polish
it as well as identify improvements that can be made to the syntax and behavior
of the engines. I appreciate your contribution.

As such, syntax may not be stable across versions. It is very possible that
limitations and issues with the language definition will be identified and
adjustments will need to be made.

Thank you. Good luck. Godspeed. `o7`